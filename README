
This is a work in progress....










This repository is for learning assembly language programming, and other
things using the little computer 3 instruction set.

http://en.wikipedia.org/wiki/LC-3

---------------------------------------------------------------------

This document is targetted toward average programmers.  C experience
is not specifically required, but enough general programming knowledge
to the point that you can read C programs is required as C will be used
as a bridge between your programming knowledge and assembly language
and the other topics discussed.

The tools are all written in C so the ability to compile and run them
is required.  They are written to be very portable and will hopefully
compile and run on your system.

---------------------------------------------------------------------

What assembly language is not:

Assembly language is not, generally, the language you use for device
drivers, nor is the primary language for bare metal program or other
forms of low level programming.  Mostly C is used for such things but
other languages work as well.  Yes some assembly is required for some
things, but it is way less than one percent of the overall code, in
general.   And yes some folks use it heavily for fun or to prove a point
or other reasons.

Assembly language is not a unversal language for all processors in the
sense that there is one assembly language and one instruction set.  This
instruction set should really not take more than an evening to learn for
an average programmer (any other language C, Python, whatever), the
things that might cause a hang up would/should cause a similar hang up
in any other language (C, Python, Java, whatever) like bitwise logical
operations.  Learning this lc-3 instruction set does not mean you can
then run off and program in assembly language for your phone or computer.
Those devices use a different instruction set and if you want to know
the assembly language for those you need to learn that separately.  The
good side of this is that each new instruction set you learn is much
easier than the last, much easier than learning multiple high level
languages (C, Python, Java, whatever).

Generally assembly languages are not standardized, what does conform
to a hard standard is the instruciton set, the machine code, the bits
that make the processor do things.  If there is more than one assembler
(the program, like a compiler, that converts the assembly language
source code into something lower level, usually machine code) for a
particular instruciton set, each author may choose to implement a
completely different "language" as in the keywords and other syntax
that make up the programming language.  The GNU assembler is well known
for messing up instruction sets.  In this case (lc-3) I am not going
to conform to the assembly language supported by the inventors text book.

What assembly language is:

Assembly language is a programming language like C or Python or Java.

Assembly language instructions generally attempt to have a one to one
relationship with machine code instructions.  Another way to say this
or think about this is that often a single line of assembly language
results in a single machine code instruction.  There are of course
exceptions, directives used to communicate something to the assembler.

High level languages C, Python, Java are converted from the text file
form into something lower using a compiler.  The term compiler is not
normally used for assembly language, instead the term assembler is used.
Unfortunately, it is not uncommon to see the term assembler used as a
reference to the language not the tool used to convert the language into
machine code.

---------------------------------------------------------------------

The little computer 3, lc-3, is an educational instruction set, it is
certainly possible to turn it into hardware and do useful things with
it but it is better served as an educational tool.  A stepping stone
up to larger more complicated instruction sets.

This tutorial and repository will attempt to show you not only how to
get started in assembly language programming, but it will do this
by showing you the machine code, showing you at least one instruction
set simulator, an assembler and a disassembler.

Most of the assembly language lessons are delivered in a way where you
are expected to type them in yourself, assemble and run them with the
simulator and get the same results as the tutorial.  You of course could
cut and paste them instead of typing but then you leave a hole in your
education.  The typing and debugging side of programming using these
tools and this language.

You will need appendix A from this book:

http://highered.mcgraw-hill.com/sites/0072467509/

The direct link is here:

http://highered.mcgraw-hill.com/sites/dl/free/0072467509/104653/PattPatelAppA.pdf

Let me know if these links dont work or if this material becomes
unavailable.

----------------------------------------
Lesson 0: Building and testing the tools

These tools were written to be portable, so they should build and work
on most systems.  Windows, Linux, Apple, etc.

If you dont already have a C compiler either a gcc or clang/llvm based
compiler, pre-built binaries, should be easy to come by.  The Makefile
shows the command lines for each of the tools

gcc :
    gcc -o lc3sim lc3sim.c readhex.c
    gcc -o lc3asm lc3asm.c
    gcc -o lc3dis lc3dis.c readhex.c
    gcc -o vsim vsim.c readhex.c


clang:
    clang -o lc3sim lc3sim.c readhex.c
    clang -o lc3asm lc3asm.c
    clang -o lc3dis lc3dis.c readhex.c
    clang -o vsim vsim.c readhex.c

If you have make then the default

> make

should build using gcc/gnu, if you use clang then

> make clang

will build using the clang/llvm compiler.

To verify the tools work

> ./lc3asm test.asm
(on windows it might be in the form .\lc3asm.exe instead)

> ./lc3asm test.asm
label0000: [0x00003003] [top] 0
label0001: [0x00000005] [top] 1
0x3000: 0x9040
0x3001: 0x5060
0x3002: 0x1027
0x3003: 0xF067
0x3004: 0x103F
0x3005: 0x0BFD
0x3006: 0xF025

> ./lc3dis test.asm.hex
0x3000: 0x9040 not r0,r1
0x3001: 0x5060 and r0,r1,#0x0000
0x3002: 0x1027 add r0,r0,#0x0007
0x3003: 0xF067 trap 0x67
0x3004: 0x103F add r0,r0,#0xFFFF
0x3005: 0x0BFD brnp 0x3003 ; -3
0x3006: 0xF025 trap 0x25

> ./lc3sim test.asm.hex
show 0x0007
show 0x0006
show 0x0005
show 0x0004
show 0x0003
show 0x0002
show 0x0001
halt

Assuming test.asm has not been changed the output from these three tools
should match the above.

----------------------------------------
Lesson 1: Getting started

Reminder, don't cut and paste, type the following program into a text
editor, using the commands from lesson one (lc3asm, lc3sim) assemble
and run the program.

;---- lesson 1 ----
add r0,r0,#1
trap 0x67
add r0,r0,#2
trap 0x67
trap 0x25
;---- lesson 1 ----

./lc3asm lesson1.asm
0x3000: 0x1021
0x3001: 0xF067
0x3002: 0x1022
0x3003: 0xF067
0x3004: 0xF025

./lc3sim lesson1.asm.hex
show 0x1235
show 0x1237
halt

What does it do?

Here is where we dive in.  First, registers, registers in the context of
processors are similar to variables in a programming language, except
there are a fixed number of them.  Different processor architectures
have a different number of registers.  In general some registers are
considered general purpose and some special purpose, again different
architectures have different mixes of special and general and it is not
uncommon to have some special registers that can be used or accessed
as general purpose registers.

The lc3 architecture has 8 registers, named r0,r1,r2,...,r7.  They are
all considered general purpose, but a couple do have a special purpose
as well.  R6 is used as the stack pointer (The stack and stack pointer
will be covered in a future lesson).  R7 is used as a return address
for function/subroutine calls (a future lesson).

Now in general processors do not actually halt, you turn them on,
they start up based on some known rules, and then run forever.  When
you run a program on your computer, that program may start and finish
but the operating system keeps running.  Even if it shows 0% cpu usage
that means applications, the operating system keeps running, it has an
idle loop that measures how much time is the operating system idling
vs running other software.  It is still running.  There are some
microcontrollers, that are designed to hibernate or go into some sort
of low power mode that has a fast wake up, like pressing the button on
your television remote control.   For educational purposes this processor
does have a halt command so that programs like the one above can run
briefly then halt.  It is not uncommon for a processor architecture to
have a specific instruction for making system calls.  System calls
meaning a place where the operating system in a loose sense of the term
can wait for applications to ask for something from the operating system
printing, file I/O, etc.  The lc3 architecture uses the trap instruction
for system calls.  The format of the trap instruction is

trap vector

where vector is a number from 0 to 255

The vector 0x25 has been defined in the lc3 documentation as halt.  My
simulator also uses that trap to halt.  I have added my own trap, number
0x67 to print the contents of register r0, as a debugging and
demonstration tool.  For my simulators these are done using a back door
a non-realistic trick in the simulator and not actual lc3 code talking
to virtual lc3 hardware to perform this action.  Both actions (0x25 and
0x67) could be done using lc3 virtual hardware and lc3 software.

There are two forms of the add instruction

add rd,sr1,sr2
add rd,sr1,#immed5

The first of the two performs the operation rd = sr1 + sr2, where rd,
sr1, and sr2 are registers.  Any of the 8 registers can be used in any
of these three places, you do not have to repeat any registers

add r1,r2,r3 ; r1 = r2 + r3

but you could if you wanted to

add r1,r1,r1 ; r1 = r1 + r1

The other form has two registers and an immediate

add rd,sr1,#immed5 ; rd = sr1 + immed

immed5 is a sign extended 5 bit immediate.  The term immediate means a
constant that is encoded in the instruction itself.  We will cover the
instruction encoding later, for now understand that this form of the
add instruction has 5 bits for an immediate value and the most
significant of those bits is sign extended to create a 16 bit number.

0xxxx = 000000000000xxxx
1xxxx = 111111111111xxxx

Where x can be any combination of bits from 0000 to 1111.

0000000000000000
0000000000000001
0000000000000010
...
0000000000001101
0000000000001110
0000000000001111

1111111111110000
1111111111110001
1111111111110010
...
1111111111111101
1111111111111110
1111111111111111

0x0000 to 0x000F and 0xFFF0 to 0xFFFF.

If not already you should strengthen your understanding of twos complement
this has nothing really to do with assembly language as it is used in
many/all languages.  In this case

0x0000 to 0x000F 0 to 15
0xFFF0 to 0xFFFF -16 to -1

Larger constants will be covered in another lesson.

With hardware, unless it is well defined, never assume the hardware
is initialized to anything.  General purpose registers, and memory are
two places in particular where you should not make assumptions.  My
lc3sim.c simulator as of this writing resets all the registers to the
value 0x1234, but dont assume that will always be the case.  In order
to not overly complicate the example, this example does not manage the
initialization of r0 properly, it just uses it as is.  The purpose of
this example is to demonstrate the add immediate so it works despite
the initial value of r0.

At this point we should be ready to walk through the code.

add r0,r0,#1

this means r0 = r0 + 1

trap 0x67

this is a system call specific to this simulator it prints out the
contents of r0.  The output of lc3sim below, the first show line 0x1235
is the result of this trap 0x67 instruction.

add r0,r0,#2

This performs the operation r0 = r0 + 2.  if r0 were 0x1235 as we see
from the prior trap 0x67, then r0 = 0x1235 + 2 = 0x1237

trap 0x67

outputs the current state of r0, which is now 0x1237 as expected

trap 0x25

this halts the simulation shown as a halt below

./lc3sim lesson1.asm.hex
show 0x1235
show 0x1237
halt

----------------------------------------
Lesson 2: Unconditional Branch

;---- lesson 2 ----
trap 0x67
add r0,r0,#1
brnzp skip
add r0,r0,#2
skip:
trap 0x67
trap 0x25
;---- lesson 2 ----

./lc3asm lesson.asm
label0000: [0x00000002] [skip] 1
label0001: [0x00003004] [skip] 0
0x3000: 0xF067
0x3001: 0x1021
0x3002: 0x0E01
0x3003: 0x1022
0x3004: 0xF067
0x3005: 0xF025

./lc3sim lesson.asm.hex
show 0x1234
show 0x1235
halt

Some assembly languages use the word branch, some use jump, some use
both.  From a programmers perspective processor instructions execute
linearly in the order written by the programmer, until you hit a branch
or jump which causes execution to conditionally or unconditionally
jump to a new location in the code.  In C for example


a = 7;
if(b == 12)
{
  a++;
}
c = a + 10;

there are two possible paths through this code

a = 7;
c = a + 10;

or

a = 7;
a++;
c = a + 10;

The a++; is conditionally executed, otherwise it is skipped, the code
jumps over the contents in the brackets and executes what is after. Code
like this might not have much value on the surface, but it demonstrates
an unconditional branch, the a++; is never executed, the execution jumps
over and continues after the if statement.

a = 7;
if(0)
{
  a++;
}
c = a + 10;


trap 0x67

start off by seeing what r0 is right now, in this case 0x1234 (remember
never assume its power on state).

add r0,r0,#1

r0 = r0 + 1 = 0x1235

brnzp skip

For the lc3 processor this is an unconditional branch.  Why it is
unconditional and what the nzp mean are for a future lesson.  What it
means in this form is "no matter what jump to the code starting at/after
the label skip:

add r0,r0,#2

IF EXECUTED this code would perform r0 = r0 + 2 = 0x1235 + 2 = 0x1237

skip:

This is a label, for my lc3asm assembly language a label cannot start
with a number, cannot have spaces, cannot be too long, and ends with
a colon.  The unconditional branch above is branching/jumping the code
execution to this label.  Basically the add r0,r0,#2 is being passed
over and not executed.

trap 0x67

print out the current state of r0, we see 0x1235 so that confirms that
the add r0,r0,#2 was not executed

trap 0x25

halt the simulation

----------------------------------------
Lesson 3: Logical operations AND and NOT

;---- lesson 3 ----
trap 0x67
add r1,r0,#0
not r0,r1
trap 0x67
and r0,r0,r1
trap 0x67
add r0,r0,#7
trap 0x67
trap 0x25
;---- lesson 3 ----

./lc3asm lesson.asm
0x3000: 0xF067
0x3001: 0x1220
0x3002: 0x9040
0x3003: 0xF067
0x3004: 0x5001
0x3005: 0xF067
0x3006: 0x1027
0x3007: 0xF067
0x3008: 0xF025

./lc3sim lesson.asm.hex
show 0x1234
show 0xEDCB
show 0x0000
show 0x0007
halt

For whatever reason it seems to me that folks get tripped up in bit
manipulation and logic operations more in assembly language than in
other languages.  Most/all of the languages have logic operations as well
AND, OR, NOT, XOR, etc and there is little to no difference at the
assembly language level.

Being a minimalist instruction, lc3 only has NOT and AND operations,
OR, XOR, etc have to be derived from those (future lesson).  The NOT
operation means if the input bit is a 0 the output bit is a 1, if the
input bit is a 1, the output bit is a 0.  The operation does this
on a bit by bit basis each bit in the input register is processed
separately from a functional perspective from the other bits in that
register.  So

0001001000110100 input
1110110111001011 output

With pencil and paper first you need to be able to get from hex to
binary.  I used to keep a strip of paper taped to my monitor with hex and
binary for the numbers 0 - 15, it didnt take long to memorize them, for
decimal to/from hex I just use a calculator.  Once written as binary
(the above input number is 0x1234 BTW) then the not operation is trivial
where you see a 0 write a 1 where you see a 1 write a 0.

The AND operation is also a logical operation but involves two inputs
and one output.  The truth table is as follows

00 0
01 0
10 0
11 1

The left two columns are the possible combinations of inputs for two
bits.  The right column is the result of the and operation of those
two input bits on a line.  Basically if both input bits are ones then
the output is a one otherwise the output is a zero.  Or another
way to say this is

anything anded with 0 is 0

00 0
10 0

and anything anded with 1 is itself

01 0
11 1

it commutes, the first operand could be the anything anded with zero

00 0
01 0

or anything anded with one

10 0
11 1

If I perform the operation 0x1234 AND 0x00FF, we look at these per
bit which means per column, if both items in the column are a one then
the result is a one, otherwise the result is a zero

0001001000110100
0000000011111111 AND
=====================
0000000000110100

so 0x1234 AND 0x00FF = 0x0034

Walking through the program

trap 0x67

this shows us what the current state of r0 is (0x1234)

add r1,r0,#0

r1 = r0 + 0, basically copy r0 to r1

not r0,r1

perform a bit by bit not operation on r1 the result goes in r0

0001001000110100  r1
1110110111001011  r0

r0 = ~r1 = 0xEDCB

trap 0x67

print out r0, and it confirms r0 = 0xEDCB

and r0,r0,r1

r0 = r0 AND r1

1110110111001011  r0
0001001000110100  r1
=====================
0000000000000000  r0

this was intentional, if you think about it, to get a result of 1 out of
an and you need both inputs to be a 1.  One register is the inverse of
the other, no matter what r0 was before all of this started this is
guaranteed to never have a condition where there are two ones.

trap 0x67

this confirms r0 = 0x0000

add r0,r0,#7

r0 = r0 + 7 = 7

trap 0x67

print out the 0x0007

trap 0x25

halt

There will be faster ways to do this in future examples, but this
sequence demonstrated a sequence to zero out r0 by anding the not of
r0 to itself.


----------------------------------------
Lesson 4: Flags and conditional branch

;---- lesson 4 ----
trap 0x67
add r1,r0,#0
not r0,r1
trap 0x67
and r0,r0,r1
trap 0x67
add r0,r0,#7
trap 0x67
top:
  add r0,r0,#0xFFFF
  trap 0x67
  trap 0x68
  brnp top
trap 0x25
;---- lesson 4 ----

./lc3asm lesson.asm
label0000: [0x00003008] [top] 0
label0001: [0x0000000B] [top] 1
0x3000: 0xF067
0x3001: 0x1220
0x3002: 0x9040
0x3003: 0xF067
0x3004: 0x5001
0x3005: 0xF067
0x3006: 0x1027
0x3007: 0xF067
0x3008: 0x103F
0x3009: 0xF067
0x300A: 0xF068
0x300B: 0x0BFC
0x300C: 0xF025
./lc3sim lesson.asm.hex
show 0x1234
show 0xEDCB
show 0x0000
show 0x0007
show 0x0006
psr 0x0001
show 0x0005
psr 0x0001
show 0x0004
psr 0x0001
show 0x0003
psr 0x0001
show 0x0002
psr 0x0001
show 0x0001
psr 0x0001
show 0x0000
psr 0x0002
halt

So lesson 3 got us to the point where register 0 was zeroed out then
7 was added to leave r0 with a 7.  This example shows a simple count
down loop.  The instruction set documentation has a plus sign (+)
next to many of the instructions.  This plus sign indicates the psr
(processor state register) flags are changed as a result of that operation.
Like the PC in this architecture, the PSR is not directly visible to
the programmer.

What are flags?  First off not all processors use flags, second processors
that use flags dont use the same flags or use them in the same way.
This processor has an interesting mix of flags not normally seen.  This
processor has three flags the n flag, when set indicating the result
of the operation was negative (the msbit, bit 15, was set, think about
twos complement).  The z flag which indicates the result was exactly
zero and the p flag which indicates the result was positive.

From the lc3 instruction set reference:

The condition codes are set, based on whether that result, taken as a
16-bit 2’s complement integer, is negative (N = 1; Z, P = 0),
zero (Z = 1; N, P = 0), or positive (P = 1; N, Z = 0).
All other LC-3 instructions leave the condition codes unchanged.

So, basically you can only have one flag set at a time through normal
operations, and also you will always have at least one flag set.  There
is a way to mess with these rules by messing with the psr, that is a
separate discussion.  For this example only one of the flags is set
at a time and as important at least one flag is set.

  add r0,r0,#0xFFFF

We dont have a subtract, we dont need a subtract, in logic a subtract
uses the add logic anyway, remember with twos complement to negate
a number you invert and add one.  If I want to subtract 1

0x0001  one
0xFFFE  invert
0xFFFF  and add one

so subtracting 1 is the same as adding -1.  The add immediate allows
us to add small negative numbers so

  add r0,r0,#0xFFFF

means r0 = r0 - 1;

With my lc3 assembler a label is of the form:

top:

some text that doesnt start with a zero, has no spaces and ends with
a colon.  Not unlike a label in C which you would use with a goto if
using labels and goto's were not considered a bad thing in C.  Despite
being bad perhaps you did at least learn how to use them.  Will be used
pretty much the same way here:

top:
r0 = r0 - 1;
if(r0 != 0) goto top;

We saw the add r0,r0,#0xFFFF implements the r0 = r0 - 1;

trap 0x67 we know prints out the value of r0
trap 0x68 prints out the psr

note that in the reference manual the trap instruction itself DOES NOT
modify the flags.  If you look at the source we see that this simulator
does not actually call other code for the trap 0x67 (that other code
COULD modify the flags).  Assume here that the flags are not touched
these traps are so you can see what is going on, you normally would not
have them there nor take the risk that they could be implemented with
code that doesnt preserve the psr.

So the flags dont change between the add and the brnp

  brnp top

What is brnp?  The instruction is really br for branch.  It has three
optional modifiers one for checking the n bit, one for checking the z
bit and one for checking the p bit.  We are looking for the result of
the subtract to be zero.  When the result of the subtract is a zero the
n bit is 0, the z bit is 1, the p bit is 0.

If you read the description of the br instruciton in the reference manual
you will see

if ((n AND N) OR (z AND Z) OR (p AND P))
PC = PC‡ + SEXT(PCoffset9);

The logic compares the n, z, and p test bits in the instruction with the
N, Z, and P flags in the PSR.  If any of those comparisions using an
and is true then the branch happens.  If all three of those comparisons
is false, a zero, then the branch does not happen the code falls through.

The syntax brnp means test for the n and p flags.  We are looking for
the case where the z flag is set and the n and p flags are zero.  So
brnp means we want to branch whenever the z flag is not set, when the
z flag is not set either the n or p flag is set and that would result
in a branch.

The syntax in the assembly language is to specify the label to branch
to, just like in C.  The assembler will take care of figuring out the
number of instructions to jump over and as a result will figure out the
machine code for this instruction.

We can see from the trap 0x67 (show r0) and trap 0x68 (psr) outputs

show 0x0006
psr 0x0001
show 0x0005
psr 0x0001
show 0x0004
psr 0x0001
show 0x0003
psr 0x0001
show 0x0002
psr 0x0001
show 0x0001
psr 0x0001
show 0x0000
psr 0x0002
halt

r0 is having one subracted per loop, 6,5,4,3... being positive numbers
the p flag is set for the non-zero numbers.  When the result is a zero
the psr changes to 0x0002 which is the z flag set, the n and p flags
are zero.  So the brnp does not happen, the code falls through to the
trap 0x25 which is a halt.

So in summary a brnp means if the n or p flags is set then branch
otherwise dont.  Another way to say that is if the z flag is not set
then branch.   Likewise a brnz would mean if the n or z flags are set
then branch otherwise dont.  Or if the p flag is not set then branch.

----------------------------------------
Lesson 5: The load instruction and more on branching

;---- lesson 5 ----
trap 0x67
ld r0,abc
trap 0x67
top:
  add r0,r0,#0xFFFF
  trap 0x67
  trap 0x68
  brz get_out
  brnzp top
get_out:
trap 0x25

abc: .word 0x0007
;---- lesson 5 ----


./lc3asm lesson.asm
label0000: [0x00000001] [abc] 1
label0001: [0x00003003] [top] 0
label0002: [0x00000006] [get_out] 1
label0003: [0x00000007] [top] 1
label0004: [0x00003008] [get_out] 0
label0005: [0x00003009] [abc] 0
0x3000: 0xF067
0x3001: 0x2007
0x3002: 0xF067
0x3003: 0x103F
0x3004: 0xF067
0x3005: 0xF068
0x3006: 0x0401
0x3007: 0x0FFB
0x3008: 0xF025
0x3009: 0x0007

./lc3sim lesson.asm.hex
show 0x1234
show 0x0007
show 0x0006
psr 0x0001
show 0x0005
psr 0x0001
show 0x0004
psr 0x0001
show 0x0003
psr 0x0001
show 0x0002
psr 0x0001
show 0x0001
psr 0x0001
show 0x0000
psr 0x0002
halt

This example is very similar to the previous example.  The primary
differences are this example uses the load (ld) instruction to read
a value from memory and place it in a register.  And the branching
in the loop is a little different, instead of branching if not zero
the loop is an infinite loop with an unconditional branch, inside
the loop there is a branch if zero to get out of the loop.  In C:

r0 = 7;
top:
  r0 = r0 - 1;
  if(r0==0) goto get_out;
  goto top;
get_out:


ld r0,abc

The assembler makes life easy by letting you use labels for loading or
storing values.  Load (ld) is used if you are going from memory to a
register, basically it is a read from memory.  Store (st) is used for
going from a register to memory, basically a write.  In this case there
is a label abc which is followed by a .word directive.  For this
architecture/assembler a word is defined as 16 bits the .word directive
tells the assembler the value that follows needs to be put in the program
at this location.  Unless you are putting machine code in your program
you want to avoid using a .word in an execution path.  You normally
dont want to execute .word lines.

abc: .word 0x0007

The value at abc at assembly time is 0x0007.  So basically

ld r0,abc

In one instruction replaces these steps in the prior two lessons.

add r1,r0,#0
not r0,r1
and r0,r0,r1
add r0,r0,#7

Even better the add immediate is very limited in what immediate values
can be used.  Where a .word entry can hold any bit pattern, for example

ld r0,xyz
...
xyz:
   .word 0x1234

Would put 0x1234 in r0, but this is illegal:

add r1,r0,#0
not r0,r1
and r0,r0,r1
add r0,r0,#0x1234

It would take several add instructions to get 0x1234 into r0.

  brz get_out
  brnzp top
get_out:

brz means branch if the z flag is set.  When r0 contains a 1 and then
we subtract 1 (add 0xFFFF) the result is r0 equals zero.  At that time
the z flag is set, the n and p flags are not set.  So a branch if zero
will branch, which hops over the brnzp instruction and gets us out of
the loop.  If the z flag is not set then we execute the brnzp instruction
which is also known as an unconditional branch.  We assume that at least
one of the flags is set at all times so a brnzp means branch if n or
z or p is set, which should always be true.  So

top:
  ...
  brnzp top

Is an infinite loop

  brz get_out
  ...
get_out:

is a conditional branch that gets us out of the loop.

Another way to visualize this program in C is:

r0 = 7;
while(1)
{
   r0 = r0 - 1;
   if(r0==0) break;
}




















0000 nzpoooooooooo     br[n][z][p] label
0001 dddaaa000bbbb +   add rd,ra,rb
0001 dddaaa1iiiiii +   add rd,ra,#immed
0010 dddoooooooooo +   ld rd,label
0011 sssoooooooooo     st rs,label
0100 000aaa0000000     jsrr ra
0100 1oooooooooooo     jsr label
0101 dddaaa000bbbb +   and rd,ra,rb
0101 dddaaa1iiiiii +   and rd,ra,#immed
0110 dddaaaooooooo +   ldr rd,ra,#offset
0111 sssaaaooooooo     str rs,ra,#offset
1000 0000000000000     rti
1001 dddaaa1111111 +   not rd,ra
1010 dddoooooooooo +   ldi rd,label
1011 dddoooooooooo +   sti rd,label
1100 000aaa0000000     jmp ra
1100 0001110000000     ret (jmp r7)
1101 1101xxxxxxxxx     undefined
1110 dddoooooooooo +   lea rd,label
1111 0000iiiiiiiii     trap immed








This is a work in progress....


